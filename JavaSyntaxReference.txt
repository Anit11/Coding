Data Structure and its Syntax

1. ArrayList

    ArrayList<Integer> aList - new ArrayList<>();
    aList.add(element);
    aList.add(index, element);                                                       --->add the element to the index, if an element is already present it pushes the element and insert
    aList.set(index, element);                                                       --->replaces the element in the particular index
    aList.isEmpty();                                                                 --->Is my array list empty
    Collections.min(aList);
    Collection.max(aList);
    Collections.replaceAll(List<T> list, T old_val, T new_val);
    Collections.reverse(List);
    Collections.reverseOrder();                                                      ---> returns comparator that works in reverse order
    Collections.rotate(List l, int distance)
    Collections.shuffle(List)
    Collections.swap(List, i, j)
    Collections.fill(list, T object)
    for(int i: aList)                                                                --->In this for each loop, i is the element not index

2. HashMap
    
    HashMap<Integer, Integer> hmap = new HashMap<> ();
    hmap.put(key, value);
    hmap.get(key);
    hmap.remove(key);
    hmap.containsKey(key);
    hmap.containsValue(value);
    hmap.size();
    for(int i : hmap.keySet()) { }                                                    --->to walk through when keys are not known

3. HashSet

    HashSet<Integer> hset = new HashSet<> ();
    hset.add(value);
    hset.remove(value);
    hset.contains(value);
    hset.size();
    hset.clear();                                                                     --->empties the HashSet object

4. PriorityQueue: When to use: (If I know which element I want exactly in unsorted array, Use Heap. Quick sort is a competitor and proved to be better method, yet you can use heap)
    
    PriorityQueue<Integer> pQueue = PriorityQueue<> ();                               ---> min heap
    PriorityQueue<Integer> pQueue = PriorityQueue<> (Collections.reverseOrder());     ---> max heap
    pQueue.add(value);                                                                ---> to add value to heap
    pQueue.remove();                                                                  ---> to delete root element
    pQueue.element();                                                                 ---> to get root element
    pQueue.isEmpty();                                                                 ---> returns true if collection is empty


5. Set ----- (Set contains no duplicate elements)
    
    Set<Integer> s1;
    Set<Integer> s2;
    Set<String> yourFriends = Sets.newHashSet(List of all elements);                  ---> Declare and Initialize more than 1 element in single line
    Set<Integer> s3 = new HashSet<Integer> (s1);
    s3.addAll(s2);                                                                    ---> Union of s1 and s2
    s3.retainAll(s2);                                                                 ---> Intersection of s1 and s2

6.BitSet bs = new BitSet();
    bs.get(index);
    bs.set(index, value)
    bs.clear(index)
    bs.and(BitSet obj);
    bs.or(BitSet obj);
    bs.xor(BitSet obj);
    bs.equals(obj);

7. StringBuffer and stringBuilder has almost same syntax. It is just that,
   StringBuilder :  stringBuilder is better than stringBuffer as it is faster. But it has no synchronization so it is not safe with multithreads. In such case, stringBuffer is used.
    StringBuilder s = new StringBuilder();                                           --->creates a empty builder
    s.append(str1);                                                                  ---> append the string representation of any data type
    s.deleteCharAt(index);
    s.delete(startIndex, endIndex);                                                  
    s.insert(index, string or char);                                                 --->  insert the char or string starting from the given index
    s.setCharAt(index, char);                                                        ---> specified index is set to the character
    s.indexOf(string)                                                                ---> return the first occurance of the substring within the string
    s.indexOf(string, fromIndex)                                                     ---> return the index of the substring starting from the fromIndex
    s.reverse();                                                                     ---> reverse string builder
    s.replace(start, end, string);                                                   ---> replace the substring between the start and end index to the given string
    s.length();                                                                      ---> return the length char inside builder
    s.capacity();                                                                    ---> returns the current capacity of the builder
    s.charAt(index);                                                                 ---> returns the character value in the sequence
    s.substring(start, end);                                                         ---> returns the new string with the substring, start is inclusive and end is exclusive
    String result = s.toString();                                                    ---> StringBuilder to string

8. Queue
    Queue<datatype> myQueue = new LinkedList<>();
    myQueue.add(data);
    myQueue.remove();
    myQueue.isEmpty();
    myQueue.size();

9. Stack (extends vector class so some of vector methods can be used here)
	Stack s = new Stack();
	s.push('a'); | s.push(2); | s.push("abc");										 --->push either a char, string or int(no need to specify the type
	s.pop();																		 --->pop the top element
	s.peek();																		 --->returns the top element without popping from stack
	s.search('a') | s.search(2); | s.search("abc");									 --->search and return the index of the element(counts from top), if element not present it returns -1
	s.size(); 																		 --->returns the current size of the stack
	s.capacity();																	 --->returns the capacity of the stack, which grows in size of 10 when element is pushed

10. Deque: (double ended queue)
    Adds: 
	    add(element) - add an element to the tail
	    addFirst(element) - adds an element to the head
	    addLast(element) - add an element to the tail
	    offer(element) - adds an element to the tail and return boolean
	    offerFirst(element) - adds an element to the head and return boolean
	    push(element) - adds an element to the head
    Removes:
	    pop(element) - removes the element from the head and return it
	    removeFirst() - removes the element at the head
	    removeLast() - removes the element at the tail
    Retrieves: 
	    poll() - retrieves and removes the head of the queue, return null if the dequeue is empty
	    pollFirst() - retrieves and removes the first element of this queue, returns null if the dequeue is empty
	    pollLast() - retrieves and removes the last element of this dequeue, returns null if the dequeue is empty
	    peek() - retreives but does not remove the head, returns null if the dequeue is empty
	    peekFirst() - retreives but does not remove the first element, returns null if the dequeue is empty
	    peekLast() -  retreives but does not remove the last element, returns null if the dequeue is empty

11. String
    "GeeksforGeeks".length();
    "GeeksforGeeks".charAt(3);
    "GeeksforGeeks".substring(3);    --->returns “ksforGeeks”
    "GeeksforGeeks".substring(2, 5); // returns “eks”

    String s = ”Learn Share Learn”;
    int output = s.indexOf(“Share”);                                                 --->returns 6
    int output = s.indexOf("ea",3);                                                  --->returns 13
    int output = s.lastIndexOf("a");                                                 --->returns 14
    
    Boolean out = “Geeks”.equals(“Geeks”);                                           --->returns true
    int out = string1.compareTo(string2);                                            --->Compares two string lexicographically, returns int(returns difference s1-s2) 
                                                                                         < 0 string1 comes before string2
                                                                                         = 0 string1 and string2 are equal
                                                                                         > 0 string1 comes after string2
    string1.compareToIgnoreCase(string2);                                            --->Compares two string like above ignoring the case
    string1.concat(string2);                                                         --->append second string to the end of first string
    string1.contains(CharSequence);
    Character.toLowerCase(str.charAt(i));                                            --->convert a character in a string to lowercase
    String word2 = word1.toLowerCase();
    String word2 = word1.toUpperCase();
    String word2 = word1.trim();                                                     --->removes white spaces at both ends
    String s2 = “feeksforfeeks”.replace(‘f’ ,’g’);                                   --->returns “geeksgorgeeks”
    string.split("-");                                                               --->returns the string[] array

11 a. Ways to create/represent a String
    byte[] b_arr = {71, 101, 101, 107, 115};
    Charset cs = Charset.defaultCharset();
    StringBuilder s_builder = new StringBuilder("Geeks");
    StringBuffer s_buffer = new StringBuffer("Geeks");
    int[] uni_code = {71, 101, 101, 107, 115};
    char char_arr[] = {'G', 'e', 'e', 'k', 's’};

    String s_byte =new String(b_arr);                                                --->Geeks
    String s_byte_char = new String(b_arr, cs);                                      --->Geeks
    String s = new String(b_arr, "US-ASCII”);                                        --->Geeks
    String s = new String(b_arr, 1, 3);                                              --->eek
    String s = new String(b_arr, 1, 3, cs);                                          --->eek
    String s = new String(b_arr, 1, 4, "US-ASCII”);                                  --->eeks
    String s = new String(char_arr , 1, 3);                                          --->eek
    String s = new String(uni_code, 1, 3);                                           --->eek
    String s = new String(s_buffer);                                                 --->Geeks
    String s = new String(s_builder);                                                --->Geeks

12. Float   - java.lang.Float
    Float.compare(f1, f2)                                                            --->returns less than 0 if f1 is less than f2, greater than 0 if f1 is greater than f2, 0 if equal
    
13. Array (for any primitive)
	Arrays.sort(string or int)														           --->sort array of any primitive type
	Arrays.equals(string1, string2)                 								 --->checks the equality of any two primitive in a array
	Arrays.deepEquals(string1, string2)												       --->checks the equality of two 2d matrix of any two primitive

14. Conversions
    //TO INT
    character to int                    - (int)character;                            --->This returns ascii int value of character eg: (int)3; is 51
    character to int values             - Character.getNumericValue(char);           --->This returns integer char of char eg: Character.getNumericValue('3'); is 3
    "     "       "      " with ascii   - int a = '3' - '0'; a = 3;                  --->The character 0 has ascii 49. So if we minus that it returns the actual number
    String to integer                   - Integer.parseInt(str);                     --->If the string does not hold 'number' inside it, it throws number format exception
	Integer or int to float, double 	- typecast it

    //TO STRING
    char to String                      - String.valueOf(char);
    int to String                       - String.valueOf(int);
    charArray to String                 - String string = new String(charArray);
	Integer to String - String.valueOf(1234);

    //TO CHAR
    int to character                    - (char)integer;
    single digit int to some char       - (char) (int - '0');                        ---> convert the single digit int to appropriate character. Missing typecast would say lossy conversion
    String to char                      - string.charAt(index);

	//STRING to CHAR ARRAY
    String to char Array                - string.toCharArray();

15. Character: (Difference between char and character is that Charater is a object so many inbuilt operations can be made use of.)
    my_char.toLowerCase();
    my_char.toUpperCase();
    my_char.isDigit();                                                              ---> Whether the char is a digit
    my_char.toString();

16. for loop:
    for (char s: string.toCharArray()) {                                            ---> converting string to char array in for loop
      for (char j: chararray) {                                                     ---> for each element in char array
      }
    }
--------------------------------------------------------------------------------------------------------------
BASICS TECHNICAL KNOWLEDGE FOR INTERVIEW QUESTIONS

1. Find Min and Max of a list
   Initiate Min to INTEGER.MAX_VALUE;   ---- 2^31-1  -32 bit system
   Initiate Max to INTEGER.MIN_VALUE;   ---- -2^31 

2. Math
    Math.random() * 50 + 1;                                                          ---> returns a double value. If you want int, typecast it. Math.random gives a value between 0 and 0.999.
	Min + (int)(Math.random() * ((Max - Min) + 1))									 ---> returns value between min and max

3. Default values for primitive data types
   byte = 0; 
   short = 0;
   int = 0;
   long = 0l;
   float = 0.0f
   double = 0.0d
   boolean = false;
   Object = null;
   class members automatically allocates default value while method variables has to be initialized.

4. what is the range of 
    1. int - -2147483648 to 2147483647
	2. Long - -9223372036854775808 to 9223372036854775807
    3. char - ascii 0 ie null to ascii 127 ie DEL (for 127 char encoding, i.e, 1 byte)
		'5' has the int value 53
		if we write '5'-'0' it evaluates to 53-48, or the int 5
		if we write char c = 'B'+32; then c stores 'b'

	Dec  Char                           Dec  Char     Dec  Char     Dec  Char
	---------                           ---------     ---------     ----------
	  0  NUL (null)                      32  SPACE     64  @         96  `
	  1  SOH (start of heading)          33  !         65  A         97  a
	  2  STX (start of text)             34  "         66  B         98  b
	  3  ETX (end of text)               35  #         67  C         99  c
	  4  EOT (end of transmission)       36  $         68  D        100  d
	  5  ENQ (enquiry)                   37  %         69  E        101  e
	  6  ACK (acknowledge)               38  &         70  F        102  f
	  7  BEL (bell)                      39  '         71  G        103  g
	  8  BS  (backspace)                 40  (         72  H        104  h
	  9  TAB (horizontal tab)            41  )         73  I        105  i
	 10  LF  (NL line feed, new line)    42  *         74  J        106  j
	 11  VT  (vertical tab)              43  +         75  K        107  k
	 12  FF  (NP form feed, new page)    44  ,         76  L        108  l
	 13  CR  (carriage return)           45  -         77  M        109  m
	 14  SO  (shift out)                 46  .         78  N        110  n
	 15  SI  (shift in)                  47  /         79  O        111  o
	 16  DLE (data link escape)          48  0         80  P        112  p
	 17  DC1 (device control 1)          49  1         81  Q        113  q
	 18  DC2 (device control 2)          50  2         82  R        114  r
	 19  DC3 (device control 3)          51  3         83  S        115  s
	 20  DC4 (device control 4)          52  4         84  T        116  t
	 21  NAK (negative acknowledge)      53  5         85  U        117  u
	 22  SYN (synchronous idle)          54  6         86  V        118  v
	 23  ETB (end of trans. block)       55  7         87  W        119  w
	 24  CAN (cancel)                    56  8         88  X        120  x
	 25  EM  (end of medium)             57  9         89  Y        121  y
	 26  SUB (substitute)                58  :         90  Z        122  z
	 27  ESC (escape)                    59  ;         91  [        123  {
	 28  FS  (file separator)            60  <         92  \        124  |
	 29  GS  (group separator)           61  =         93  ]        125  }
	 30  RS  (record separator)          62  >         94  ^        126  ~
	 31  US  (unit separator)            63  ?         95  _        127  DEL

    4. float -  not sure(check it)
    5. decimal - not sure(check it)
	6. Bytes - 	-128 to 127
	7. Short - -32,768 to 32,767
	Objects won't have min and max value. 

4. String to Integer - Integer.parseInt("1234");
   Integer to String - String.valueOf(1234);
   Integer to float, double - typecast it
   int to Integer and its difference?
		i) Integer is an object and int is the primitive data type.
		ii) create Integer object with int as parameter

5. Number system: Base
   Binary - 2 (0, 1) - represented as 0b
   Decimal - 10 (0-9)
   Octal - 8 (0-7) - represented as 
   Hexadecimal - 16 (0-9, a-f) - represented as 0x

6. .length()  - used for finding length of string, string builder                
   .length - used for finding length of char array
   .size() - ArrayList uses this.

7. Difference between declaring int a; and int a = new int();
   int a = new int() is not a valid statement. The new operator cannot be used for primitive data.   int a allocates 4 byte of memory depending on system.

8. System.exit(0) - returns the information to the system that the program exit normally
   System.exit(1) - returns the information to the system that the program exit due to error(crashed)

9. Formatting the number
	int number = 12345;
	DecimalFormat decimalFormat = new DecimalFormat("#,##0");
	String numberAsString = decimalFormat.format(number);
	System.out.println(numberAsString);

	Output: 12,345

10. Iterate HashMap
	for each loop:
		//iterate entire key value pair
		for(Map.Entry<String, Integer> obj: hmap.entrySet()) {
			String key = obj.getKey();
			int value = obj.getValue();
		}
		
		//iterate key set
		for (String key : hmap.keySet()) {
			System.out.println("Key = " + key);
		}

		//iterate values
		for (Integer value : hmap.values()) {
			System.out.println("Value = " + value);
		}
	
	Iterator:
		Iterator entries = hmap.entrySet().iterator();
		while (entries.hasNext()) {
			Map.Entry entry = (Map.Entry) entries.next();
			Integer key = (Integer)entry.getKey();
			Integer value = (Integer)entry.getValue();
			System.out.println("Key = " + key + ", Value = " + value);
		}

11. Iterate HashSet

	//for each loop
	for (String temp : hset) {
        System.out.println(temp);
     }

	//Using Iterator
	{
		Iterator<String> it = hset.iterator();
			 while(it.hasNext()){
				System.out.println(it.next());
			 }
	}

//BIT MANIPULATION
12. Find number of bit in the binary of a number  -  log2 number + 1;
	Find number of digits in a int number		 -  log10 number + 1;

13. To check if bit is set to 1 in nth position in  a binary number -
	int check = 1;
	check << n;
	if(number == (check | number)) {
		S.o.p("yes");
	}

14. Unset left most set bit in binary
	n&(n-1)
	 
15. count set bits (i.e, number of 1 in binary number) 
	while(n) {
		n & (n-1);
		i++;
	}
	//when n is 0 loop stops

16. Find right most set bit 
	n & ~(n-1)

//JAVA LOGARITHMS
17. To find log number of 
	base 2
		log(number) / log(2);
	base 10
		log(number) / log(10);

--------------------------------------------------------------------------------------------------------------
UNDERSTANDING BASICS

1. difference between for loop and Iterator?
    http://stackoverflow.com/questions/22267919/iterator-vs-for

2. What is boxing and Autoboxing?
    Boxing is converting primitive types to corresponding object. Example is int to INTEGER object. 
    List<Integer> li = new ArrayList<>();
    for (int i = 1; i < 50; i += 2)
        li.add(i);																		 ---> adding int as Integer object to list
    If boxing is done automatically, it is called autoboxing

    UnBoxing is reverse of that.
    public static int sumEven(List<Integer> li) {
        int sum = 0;
        for (Integer i: li)
            if (i % 2 == 0)                       										 ---> Integer i is calculated for its modulo with 2
                sum += i;
            return sum;
    }

3.Difference between HashTable and HashMap?

4. Is array an object in java?
    http://stackoverflow.com/questions/8781022/is-an-array-an-object-in-java
    Yes, array is an class. array instance is a object. array.length is not a method, it is a field in array class.

5. Can a array be null?
    http://stackoverflow.com/questions/2369967/how-we-check-for-null-array-in-java
    Yes, it can be. Array is a class and any object can be null in java. 

6. Can a final variable be redefined by the method that uses it? (Assume final variable is declared in the class and initialized inside method)
    Why final?  - to create a value as constant. 
        Types: 
        1. COMPILE TIME constant. create primitive data type with keyword final and initialize it before accessing it. 
                                  Value is assigned at compile time, it pre-load the value while compiling so at run time it will be easy.
                                  eg: final int a=5, int c = b+a, it writes it as c = b+5 after compilation), 
                                  Class variable declared as final should be initialized no matter if you are using it are not
                                  (In general default value will be assigned to class variable, but in case of final, the default value cannot be initialized so it need to be assigned)
        2. RUN TIME constant(value assigned in runtime) - class variable can be initialized inside constructor.
                                                        - when the object is called, it passes the value and initialize the final class variable.
                                                        - method variable can be initialized at run time. It just has to be initialized before accessing it.
        3. If class is final, I cannot inherit the class
        4. If method is final, I cannot override the method, i.e, the method cannot be rewritten by the child class when the parent class is inherited.
    why static? 
    - all member of class can access to the same copy. It means it is shared across different object with the same value.
    - should not access static variable with object. It can be accessed by static methods only.
    what is super keyword?
    what is this keyword?
    
7. What happens when we declare with new eg: ArrayList<Integer> arr; and ArrayList<Integer> arr = new ArrayList<Integer> ();
    If you create ArrayList arr, it just creates a reference arr that can point to a Integer arrayList in future. The new keyword creates the memory for the arr reference where you can store the values in future.
	
    http://stackoverflow.com/questions/214741/what-is-a-stackoverflowerror
    Stack memory is used to store local variables and parameters. 
    When an recursive is called continuously, the stack stores the local variables and parameters of every recursive call which sometime may overflow stack. 
    This is why you get the stack overflow error while the base case is not written or while running a recursive call that need to store large data.
	
8. How to do swap in arraylist without using Collection function?
	Using set function, arrList.set(index, value) will replace the value that was originally present

9. What is difference between function overloading and function overriding
    See Prag OOPS notes.

10. Passing variable to a function means passing address or passing values in java?
11. How to find min and max value of a floating or double point number?
	The min and max value is identified by float.compare(f1, f2). It returns -1 when f1 is smaller, 0 if f1 and f2 are equal, 1 if f2 is greater than f1

12. Which is better? Declaring variable inside loop or outside?
13. When is memory allocated in java? Compile time or run time
14. What happens when I do? i=i+1; i+=1; i++;
15. How to declare max and min value when is needed?
    INTEGER.MAX_VALUE; for max int. 
    INTEGER.MIN_VALUE; for min int.
    Collections.max(list);
    Collections.min(list);

16. How are ascii values assigned and distributed
17.	How to declare class that accepts any value
18.	public, private, protected, default
    Public - 
    Default - 
    Private - 
    Protected - 

19.	Can we write class inside class?
    Yes, we can. Inner class will be hidden to the outer world.
    Inner class has to be static

21.	how to write comparator
22. how to convert hexadecimal to binary
23. Study conversion of number system
25. what is an object?
    Object is the instance of a class. Object holds the copy of class members not class methods. Using the member, you can access the class methods to perform some operation on class members. 

26.	what is double hashing? why is it required.
28.	when to use backtracking, divide and conquer
    Mostly it is used in gamings. When you are not sure your placement of value is right in that particular time. You can make the program play with dropping the value. 
    After winning or losing program tracks its way back to the current position. 
    Such tacking back is back tracking.

30. where are local variables stores while the program runs
    Local variables are local to its method. Local variables are stored in stack segment.

31.	how are local variables and value to it is assigned and stored
    Local variable are primitive data type local to its method.
    primitive data type: Local variables are assigned with respective memory. When initialization happens the memory allocated is written. Initially it can have garbage value(not accessible in java)

32.	The assignment of variable will happen during compile time or run time
    I guess it is compile time in java. Check it.

33.	what compiler does java use 
    Java compiler program is included in JDK. 
    There are many compilers available. Few are Eclipse Compiler for Java(ECJ), GNU compiler for java etc

34. What is difference between abstraction and encapsulation?
    Encapsulation is like a black box. The outside world knows there is a box so called but they have no idea what is inside or how does it operate. The class members are private.
    Abstraction is again hiding of data. The user even though knows the data in class it cannot access unless it inherits it. Abstract class cannot be instantiated.

35. Can I have nested class? what is the use of it?
    Yes, a class can be nested. The inner class belongs to the outer class and only the outer class knows it exist. This happens when there is a need for encapsulation. Eg: Graph class can have Node class as inner class, because it is part of Graph and no one other than Graph class need to know or instantiate it.
    Inner class should be static.

36. Find square root of number
37. what does ~ operator do?
38. what does >>> operator do?
39. what does instanceOf operatoor do?
    It returns boolean after checking if the given object is the instance of the particular class. If yes, true, else, false.

40. what does iternery operator do? "? :"
    It is similar to if else statement.
	eg: result = someCondition ? value1 : value2;
	result = value1  if someCondition is true, 
	result = value2  if someCondition is false.

41. what is the syntax for finding minimum  and maximum value using int, Integer, long, Long, float, Float, double, Double
	Float, Double:
		Float.MIN_VALUE;		--> It is positive, MIN_VALUE tells how precise value can be not actual min. It should have been names as Epsilon. Actual min is -(FLOAT.MAX_VALUE)
		Double.MIN_VALUE;		--> same with double
		Long.MIN_VALUE;
		Long.MAX_VALUE;
		Integer.MIN_VALUE;
		Integer.MAX_VALUE;

42. How to sort strings in lexographical order
43. what all classes use .valueOf() (see Byte, Integer, Long, Float, Double)
44. See useful methods in float double.
45. what is assertion?
46. how to convert lowercase to uppercase(character, string)
47. overview of generics
48. what does enum do? overview 
49. what is the difference between error and exception
50. existing function for FLOAT TO INTEGER, INTEGER TO FLOAT
51. why do people want to convert int or any datatype to byte array? what is the use of it.
52. Internal Fragmentation:
    OS divides the memory into fixed size blocks. If the
53. What does static variable mean? 
   It has the universal memory across object. 
   The different objects created for same class shares same value for static variable.
   What does static method mean? 

54. Final:
   class - cannot be inherited
   variable - cannot be changed
   method - cannot be overridden

55. Super:
56. this:

57. Different kinds of block in class
	Initialization block : will be inbetween { and }, and it will be executed everytime instance of the class is called. It is executed before constructor by the call by "super" keyword in constructor. All initialization method are written in the order it is written. Example, 

	class Dog {
		// begin instance initialization block
		{
			System.out.println("Dog's Instance Init Block");
		}
		// end instance initialization block
	 
		public Dog() {
			System.out.println("Dog's constructor"); // a super constructor is called before executing the constructor commands.
		}
	}
	Output: Dog's Instance Init Block
			Dogs Constructor
	
	Static block : will be executed only one when the class is loaded for the first time. It executes before the any other block in class (even before initialization block). All static methods are executed in the order it is written. 
	class Bird {
		static {
			System.out.println("Bird's Static Init Block #1");
		}
	 
		public Bird() {
			System.out.println("I'm a bird");
		}
	 
		{
			System.out.println("Bird's Instance Init Block #1");
		}
	 
		public void fly() {
			System.out.println("I'm flying");
		}
	 
		{
			System.out.println("Bird's Instance Init Block #2");
		}
	 
		static {
			System.out.println("Bird's Static Init Block #2");
		}
	}	
	
	Output: (when the object is initialized or class is loaded for the first time) 
		Bird's Static Init Block #1                       //when the class is loaded for the first time, order is maintained
		Bird's Static Init Block #2						  //when the class is loaded for the first time
		Bird's Instance Init Block #1					  //whenever the object is initialized
		Bird's Instance Init Block #2					  //whenever the object is initialized
		I'm a bird	

58. How JVM works? 
   java code is compiles into byte code(.class file). When we run it, Just-in-time compiler converts it into machine code and run it(Hence it takes more time than C or C++).
59. RAM Memory management:

http://stackoverflow.com/questions/23334018/how-to-delete-a-java-object-from-heap
http://www.geeksforgeeks.org/g-fact-46/
   
   Stack - stores the local variables. its scope in method or class.
   Heap - stores the dynamically allocated variables or object(created using new). Java removes it. else you can make the object null.
   Data Segment - stores the global variables and static variables. file scope.
   Code Segment - has the code to execute. Scope is till program runs.

60. Synchronization:
It allows only one thread to execute the method at a time. Others has to wait. Vector implements Synchronization.

61. How does garbage collection work?
62. Difference between String Builder and String Buffer?
    Both String Builder and String Buffer are mutable unlike String object.
    String Buffer is often used in multi threaded environment as it provides high synchronization. String Builder is not synchronized so it is generally used in single threaded environment, also it is faster because of the same reason.
63. What is Deque?
64. What is ItemWrapper?
65. Difference between string1.concat(string2) and string1+string2?
    If either of string is null, 'concat' throws an exception whereas '+' don't.

-----------------------------------------------------------------------------------------
OOPS:

1. Abstract: 

http://stackoverflow.com/questions/197893/why-an-abstract-class-implementing-an-interface-can-miss-the-declaration-impleme
http://stackoverflow.com/questions/56867/interface-vs-base-class
http://stackoverflow.com/questions/479142/when-to-use-an-interface-instead-of-an-abstract-class-and-vice-versa
http://stackoverflow.com/questions/21537982/should-i-implement-all-methods-in-abstract-class

   i) Abstract method: declared but no implementation
   ii) Abstract class: Incomplete class. It does not define all of its methods.
   
   iii) when implementing abstract method - when the implementation is not known at that time and the derived class should implement it else the derived class is abstract.
   
   iv) Can Abstract class be instantiated, why? - No, because when we create object we give permission to access it methods whereas one or more of its method is incomplete.
   
   v) difference between abstract and interface - 
   In Interface all methods have no implementation, while in abstract class only one or few methods have no implementation.
   If abstract class, then it need not implement all methods its interface methods. But its derived class has to implement all the methods of interface.
  
   vi) When to use abstract class and interface - Use abstract clases and inheritance if you can make the statement "A is a B". Use interfaces if you can make the statement "A is capable of [doing] as", or also, abstract for what a class is, interface for what a class can do. For example, we can say a triangle is a polygon but it makes no sense to say a triangle is capable of being a polygon.

2. Polymorphism:
   Check Prag notes.

3. Method Overloading: Two method having same method name
4. Method Overriding: Method signature is same as base class but derived class will have its own implementation. Compiler calls the derived class since it is considered that derived class will have appropriate implementation.

-----------------------------------------------------------------------------------------
DataStructures: Set, stack, queue, LinkedList, Map, tree, graph

2. try catch throw complete explanation and use
3. red black tree and other common tree
4. bit manipulation
5. what is hash tree?
6. what is adjacency list
7. StringBuilder
8. Multithreading
9. threading
10. vector and arraylist diff
11. trie?
12. what does exactly ..void main(String args[]) do?
13.	radix sort?
14.	diff between for loop and iterator?

-----------------------------------------------------------------------------------------
Pragadheesh notes: OOPS

1. What is Abstraction:
    - Abstraction is the concept of ignoring unnecessary details.
    - Or other words, describing something in a simpler way by not concentrating on the intricate details and focusing only on necessary details.
    - It can be thought as generalization.
    - Say when you are meeting a random person, you would say that you are the guy in Black Shirt and Blue Jean.
    - We can consider Interfaces as Abstraction.

2. What is Encapsulation:
    - Encapsulation is something like group similar things in a box.
    - So someone else won't have access to the inside of the box. They can just use the box to do what they want.
    - Changing the contents of the box won't affect the outsider. They will still be able to use the box.

3. What is Polymorphism:
    - Polymorphism is the ability of an object to decide what it should.
    - Simple example would be to consider "Shapes" class. And the class has methods like Area and Cirumferance.
    - We can have subclasses like Square, Rectangle.
    - To find the area of all the shapes, we can just give Shapes.area(). Based on what shape it is, we will get the respective Area.

4. Overriding:
    - Concept of adding more details to a function in the derived class.
    - It replaces the function in the base class.

5. Overloading:
    - It is concept of defining multiple methods based on the parameters passed.

6. What is Inheritence:
    - It is concept where a new class is derived from an existing class.
    - This happens when we want to have a new Class that will make use of an existing class with some added details to it.
    - Eg we have a Vehicle / Shapes class and we want to add Car / Square class.
    - Inheritence should only be used if the sub class is BEHAVIORIALLY equal to the superclass.

-----------------------------------------------------------------------------------------
Sorting prag notes:

1. Bubble Sort vs Selection Sort vs Insertion Sort
    http://www.sorting-algorithms.com/selection-sort
    Bubble Sort:
	https://en.wikipedia.org/wiki/Bubble_sort
        - Check pair of elements and swap them so that the largest gets bubbled to the end.
        PROS:
            If array is almost sorted OR once we have the array sorted, we can STOP there.

        Bubble sort has many of the same properties as insertion sort, but has slightly higher overhead.
        In the case of nearly sorted data, bubble sort takes O(n) time, but requires at least 2 passes through the data (whereas insertion sort requires something more like 1 pass). 

    Insertion Sort:
	https://en.wikipedia.org/wiki/Insertion_sort
        - What we have at any given time is sorted.
        PROS:
            Online Sorting
            Can you binary search for inserting into a position

        Although it is one of the elementary sorting algorithms with O(n2) worst-case time,
        insertion sort is the algorithm of choice either when the data is nearly sorted (because it is adaptive) or when the problem size is small (because it has low overhead).

        For these reasons, and because it is also stable, insertion sort is often used as the recursive base case
        (when the problem size is small) for higher overhead divide-and-conquer sorting algorithms, such as merge sort or quick sort. 


    BUBBLE SORT vs INSERTION SORT
        Bubble sort always takes one more pass over array to determine if it's sorted.
        On the other hand, insertion sort not need this -- once last element inserted, algorithm guarantees that array is sorted.

        Bubble sort does n comparisons on every pass.
        Insertion sort does less than n comparisons -- once algorith finds position where to insert current element it stops making comparisons and takes next element.

    Selection Sort:
	https://en.wikipedia.org/wiki/Selection_sort
        Select Minimum element each time and put it at the front.
        PROS:
            - Never have to do MORE THAN "n" swaps.

        From the comparions presented here, one might conclude that selection sort should never be used.
        It does not adapt to the data in any way (notice that the four animations above run in lock step), so its runtime is always quadratic.

    Quick Sort:
        Take a pivot element. 
        Run through 1 to n in array to rearrange in such a way that smaller elements are before pivot and the bigger elements are after pivot
        In other words, after each iteration, the pivot will end up in its correct index. 
        For finding an element in array, quick sort can be used as if you choose right pivot, the time complexity is somewhere equivalent to n.

-----------------------------------------------------------------------------------------
DATABASE MySQL:

1. to list db: SHOW DATABASES;
2. to create db: CREATE DATABASE mydb;
3. to delete: DROP DATABASE mydb;
4. Open database : USE mydb;

After getting inside your database:
1. to show tables in mydb: SHOW tables;
2. to create table : CREATE TABLE mytable(id INT NOT NULL PRIMARY KEY, name VARCHAR(20),subject VARCHAR(30), course CHAR(10), signup_date DATE);
3. to see description of table: DESCRIBE mytable;
4. insert: INSERT INTO `mytable` (`id`,`name`,`subject`,`course`,`signup_date`) VALUES (NULL, "John", "algorithm","cse", '2012-04-11');
5. to select all rows in table: SELECT * FROM mytable;
6. to update table information: UPDATE `mytable` SET `name` = 'John' WHERE `mytable`.`course` ='cse';
7. to update field in table: ALTER TABLE mytable ADD email VARCHAR(40);
   to add column after specific field: ALTER TABLE mytable ADD email VARCHAR(40) AFTER name;
   to drop a column in table: ALTER TABLE mytable DROP email;
8. to delete a row: DELETE from mytable where name='John';
-----------------------------------------------------------------------------------------
LINUX Commands

1. cat
    - Display entire file on shell
2. touch
    - Just creates empty file
3. less
    - View file page by page
4. grep
    - search file contents
    Eg: grep -ir "foo" .
    "i" - ignores case
    "r" - recursive
5. find
    - search file names
6. Pipe |
    - Gives output of one command as input of next command
    Eg: grep -ir "for" . | grep "map" > a.txt
    Eg: grep -ir "for" . | grep "map" | more : To view page by page
7. Redirection >
    - Write output to a file
    - Creates file if not present
8. more
    - Page by page view
9. rmdir 
    - Can only delete empty directories
10. rm -rf
    r - recursive
    f - forcefully
11. ls -alht
    a - all files including hidden
    l - list view
    h - human readable size format
    t - sort by time
-----------------------------------------------------------------------------------------
VIM Shortcuts

    1. Split View
        ctrl + w v : split vertically
        ctrl + w s : split horizontally
        ctrl + h : Go right pane
        ctrl + l : Go left pane
        ctrl + j : Go bottom pane
        ctrl + k : Go top pane
    
    2. Scroll
        ctrl + d : Half page down
        ctrl + u : Half page up
        ctrl + f : Full page down
        ctrl + b : Full page up

    % : Takes you to matching brace
    ^ : First character of line
    A : Takes you to INSERT mode at END of line
    u : Undo
    ctrl + r : redo

    H : High / Head of screen
    L : Low / Bottom of screen
    M : Middle of screen

    zt : Makes your current curson postion as top of the screen
    zb : Makes your current curson postion as bottom of the screen

    . : To repeat an action that is performed.

    * : Finds current word after cursor position;
        Use 'n' and 'N' to go next and prev
    # : Finds current word before cursor position;
        Use 'n' and 'N' to go next and prev 
    / : To start searching. It has smart Case enabled
    ,/ : To clear highlighted search term
    ' : to repeat the last find char

    ,n : Open another file on the side pane in vim by showing a tree view

-----------------------------------------------------------------------------------------
