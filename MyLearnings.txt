JAVA SYNTAX: 
1. declaring int a; and int a = new int();
2. when to use 
    1. .length()  - used for finding length of string,                
    2. .length - used for finding length of char array
    3. .size() - ArrayList uses this.
3. What does keyword do internally
    1. static
    2. finally
    3. super 
4. How garbage collection works
5. what is default value for 
    1. int
    2. string
    3. char
    4. boolean - false
6. what is the range of 
    1. int
    2. char
    3. string
    4. float
    5. decimal
    6. big decimal
7. System.exit(0) - returns the information to the system that the program exit normally
8. System.exit(1) - returns the information to the system that the program exit due to error(crashed)
9. Type cast
    1. string to char - str.charAt(0);
    2. string to char[] - str.toCharArray();
10. How does memory allocate (dynamic or not) for 
    1. String :
In Java usage and for what type of problems it is generally used:
1. List - List<String> hi = new List<String() , hi.add("abc") , hi.size() , hi.get(0) , hi.remove(0) , hi.clear()
		  Types: ArrayList, LinkedList, vector, stack

2. hashMap - uses get, put, iterator or for loop for iterating
http://javarevisited.blogspot.com/2011/12/how-to-traverse-or-loop-hashmap-in-java.html

3. bit manipulation

4. iterator - Iterator it = hi.iterator(), while(it.hasnext()), S.O.P(it.next());
   comparator - 

5. substring
6. split

7. set - Set setA = new HashSet() , setA.add(element) , 
	     Types: EnumSet, HashSet, LinkedHashSet, TreeSet - SortedSet setA = new TreeSet(); or NavigationSet setA = new TreeSet() , SortedSet ss = setA.subSet("2","4") - 2 and 4 are values

8. map 
	i) is an interface - Map mapA = new HashMap() , mapA.put("key1", "element 1") , String element1 = (String) mapA.get("key1") , 
	ii) iterator - Iterator iterator = mapA.keySet().iterator() , Iterator iterator = mapA.values() , while(iterator.hasNext(){ Object key   = iterator.next(); Object value = mapA.get(key) }
	iii) Types: hashmap, treemap
9. vector

10. String Buffer, String builder and its supportive function
	1.Why we go to String builder or buffer instead of String
		i) String is immutable(String class does not have setter, so everytime you concatenate it will create new object where object is immutable, you cannot change the value object points to whereas reference is not i.e, you can change the object reference to new value) 
		ii) so we need String builder or buffer so that it is mutable(has setter) hence you can change the existing value.
	2. Difference between String builder and String Buffer
		i)

11. bitwise left shift and right shift
12. recursion

13. Queue - Queue queueA = new LinkedList() , Queue queueB = new PriorityQueue() , queueA.add("element 1") , Object firstElement = queueA.element() - to see the element without removing it from queue, Object firstElement = queueA.remove() 
    Deque - Deque dequeA = new LinkedList() , Deque dequeB = new ArrayDeque() , dequeA.add("element 0") , Object firstElement = dequeA.remove() , Object firstElement = dequeA.removeFirst(), Object lastElement  = dequeA.removeLast();

14. Stack - Stack stack = new Stack() , stack.push("1") , Object objTop = stack.peek() , Object obj3 = stack.pop() 

15. ItemWrapper - to have a list with different datatype

16. Difference between string.concat(), and str1+str2 ?
    string.concat() concats only when string is not null else it throws exception where as str1+str2 works even if str1 is empty(null). (StringBuilder uses .append(str) for concat)

17. String Bufffer is suitable for multithread environment. If single thread, use String Builder, it is much faster.

18. String Builder is more faster and consumes less memory as string + operator creates new String everytime we make modification to string

Basics of how the program is stored in and outputed
how jam works

sorting techniques
searching techniques

Go through projects in resume 


MySQL:

1. to list db: SHOW DATABASES;
2. to create db: CREATE DATABASE mydb;
3. to delete: DROP DATABASE mydb;
4. Open database : USE mydb;

After getting inside your database:
1. to show tables in mydb: SHOW tables;
2. to create table : CREATE TABLE mytable(id INT NOT NULL PRIMARY KEY, name VARCHAR(20),subject VARCHAR(30), course CHAR(10), signup_date DATE);
3. to see description of table: DESCRIBE mytable;
4. insert: INSERT INTO `mytable` (`id`,`name`,`subject`,`course`,`signup_date`) VALUES (NULL, "John", "algorithm","cse", '2012-04-11');
5. to select all rows in table: SELECT * FROM mytable;
6. to update table information: UPDATE `mytable` SET `name` = 'John' WHERE `mytable`.`course` ='cse';
7. to update field in table: ALTER TABLE mytable ADD email VARCHAR(40);
   to add column after specific field: ALTER TABLE mytable ADD email VARCHAR(40) AFTER name;
   to drop a column in table: ALTER TABLE mytable DROP email;
8. to delete a row: DELETE from mytable where name='John';

OOPS:

1. Abstract: 

http://stackoverflow.com/questions/197893/why-an-abstract-class-implementing-an-interface-can-miss-the-declaration-impleme
http://stackoverflow.com/questions/56867/interface-vs-base-class
http://stackoverflow.com/questions/479142/when-to-use-an-interface-instead-of-an-abstract-class-and-vice-versa
http://stackoverflow.com/questions/21537982/should-i-implement-all-methods-in-abstract-class

   Abstract method: declared but no implementation
   Abstract class: Incomplete class. It does not define all of its methods.
   
   when implementing abstract method - when the implementation is not known at that time and the derived class should implement it else the derived class is abstract.
   
   Can Abstract class be instantiated, why? - No, because when we create object we give permission to access it methods whereas one or more of its method is incomplete.
   
   difference between abstract and interface - 
   In Interface all methods have no implementation, while in abstract class only one or few methods have no implementation.
   If abstract class, then it need not implement all methods its interface methods. But its derived class has to implement all the methods of interface.
  
   When to use abstract class and interface - Use abstract clases and inheritance if you can make the statement "A is a B". Use interfaces if you can make the statement "A is capable of [doing] as", or also, abstract for what a class is, interface for what a class can do. For example, we can say a triangle is a polygon but it makes no sense to say a triangle is capable of being a polygon.

2. Polymorphism:
   Prag notes.
3. Method Overloading: Two method having same method name
4. Method Overriding: Method signature is same as base class but derived class will have its own implementation. Compiler calls the derived class since
   it is considered that derived class will have more implementation.

JAVA:

1. What does static variable mean? 
   It has the universal memory across object. 
   The different objects created for same class shares same value for static variable.
   What does static method mean? 

2. Final:
   class - cannot be inherited
   variable - cannot be changed
   method - cannot be overridden

3. Different kinds of block in class
	Initialization block : will be inbetween { and }, and it will be executed everytime instance of the class is called. It is executed before constructor by the call by "super" keyword in constructor. All initialization method are written in the order it is written. Example, 

	class Dog {
		// begin instance initialization block
		{
			System.out.println("Dog's Instance Init Block");
		}
		// end instance initialization block
	 
		public Dog() {
			System.out.println("Dog's constructor"); // a super constructor is called before executing the constructor commands.
		}
	}
	Output: Dog's Instance Init Block
			Dogs Constructor
	
	Static block : will be executed only one when the class is loaded for the first time. It executes before the any other block in class (even before initialization block). All static methods are executed in the order it is written. 
	class Bird {
		static {
			System.out.println("Bird's Static Init Block #1");
		}
	 
		public Bird() {
			System.out.println("I'm a bird");
		}
	 
		{
			System.out.println("Bird's Instance Init Block #1");
		}
	 
		public void fly() {
			System.out.println("I'm flying");
		}
	 
		{
			System.out.println("Bird's Instance Init Block #2");
		}
	 
		static {
			System.out.println("Bird's Static Init Block #2");
		}
	}	
	
	Output: (when the object is initialized or class is loaded for the first time) 
		Bird's Static Init Block #1                       //when the class is loaded for the first time, order is maintained
		Bird's Static Init Block #2						  //when the class is loaded for the first time
		Bird's Instance Init Block #1					  //whenever the object is initialized
		Bird's Instance Init Block #2					  //whenever the object is initialized
		I'm a bird	


JAVA internal:
1. How JVM works? 
   java code is compiles into byte code(.class file). When we run it, Just-in-time compiler converts it into machine code and run it(Hence it takes more time than C or C++).
2. RAM Memory management:

http://stackoverflow.com/questions/23334018/how-to-delete-a-java-object-from-heap
http://www.geeksforgeeks.org/g-fact-46/

   Stack - stores the local variables. its scope in method or class.
   Heap - stores the dynamically allocated variables or object(created using new). Java removes it. else you can make the object null.
   Data Segment - stores the global variables and static variables. file scope.
   Code Segment - has the code to execute. Scope is till program runs.

3. Synchronization:
It allows only one thread to execute the method at a time. Others has to wait. Vector implements Synchronization.

Pragadheesh notes: 
1. What is Abstraction:
    - Abstraction is the concept of ignoring unnecessary details.
    - Or other words, describing something in a simpler way by not concentrating on the intricate details and focusing only on necessary details.
    - It can be thought as generalization.
    - Say when you are meeting a random person, you would say that you are the guy in Black Shirt and Blue Jean.
    - We can consider Interfaces as Abstraction.

2. What is Encapsulation:
    - Encapsulation is something like group similar things in a box.
    - So someone else won't have access to the inside of the box. They can just use the box to do what they want.
    - Changing the contents of the box won't affect the outsider. They will still be able to use the box.

3. What is Polymorphism:
    - Polymorphism is the ability of an object to decide what it should.
    - Simple example would be to consider "Shapes" class. And the class has methods like Area and Cirumferance.
    - We can have subclasses like Square, Rectangle.
    - To find the area of all the shapes, we can just give Shapes.area(). Based on what shape it is, we will get the respective Area.

4. Overriding:
    - Concept of adding more details to a function in the derived class.
    - It replaces the function in the base class.

5. Overloading:
    - It is concept of defining multiple methods based on the parameters passed.

6. What is Inheritence:
    - It is concept where a new class is derived from an existing class.
    - This happens when we want to have a new Class that will make use of an existing class with some added details to it.
    - Eg we have a Vehicle / Shapes class and we want to add Car / Square class.
    - Inheritence should only be used if the sub class is BEHAVIORIALLY equal to the superclass.


Sorting prag notes:
1. Bubble Sort vs Selection Sort vs Insertion Sort
    http://www.sorting-algorithms.com/selection-sort
    Bubble Sort:
	https://en.wikipedia.org/wiki/Bubble_sort
        - Check pair of elements and swap them so that the largest gets bubbled to the end.
        PROS:
            If array is almost sorted OR once we have the array sorted, we can STOP there.

        Bubble sort has many of the same properties as insertion sort, but has slightly higher overhead.
        In the case of nearly sorted data, bubble sort takes O(n) time, but requires at least 2 passes through the data (whereas insertion sort requires something more like 1 pass). 

    Insertion Sort:
	https://en.wikipedia.org/wiki/Insertion_sort
        - What we have at any given time is sorted.
        PROS:
            Online Sorting
            Can you binary search for inserting into a position

        Although it is one of the elementary sorting algorithms with O(n2) worst-case time,
        insertion sort is the algorithm of choice either when the data is nearly sorted (because it is adaptive) or when the problem size is small (because it has low overhead).

        For these reasons, and because it is also stable, insertion sort is often used as the recursive base case
        (when the problem size is small) for higher overhead divide-and-conquer sorting algorithms, such as merge sort or quick sort. 


    BUBBLE SORT vs INSERTION SORT
        Bubble sort always takes one more pass over array to determine if it's sorted.
        On the other hand, insertion sort not need this -- once last element inserted, algorithm guarantees that array is sorted.

        Bubble sort does n comparisons on every pass.
        Insertion sort does less than n comparisons -- once algorith finds position where to insert current element it stops making comparisons and takes next element.

    Selection Sort:
	https://en.wikipedia.org/wiki/Selection_sort
        Select Minimum element each time and put it at the front.
        PROS:
            - Never have to do MORE THAN "n" swaps.

        From the comparions presented here, one might conclude that selection sort should never be used.
        It does not adapt to the data in any way (notice that the four animations above run in lock step), so its runtime is always quadratic.

    Quick Sort:
        Take a pivot element. 
        Run through 1 to n in array to rearrange in such a way that smaller elements are before pivot and the bigger elements are after pivot
        In other words, after each iteration, the pivot will end up in its correct index. 
        For finding an element in array, quick sort can be used as if you choose right pivot, the time complexity is somewhere equivalent to n.

	

------------------------------------------------------------------------------------------------------------------------------------------------
    

Data Structure and its operations

0. ArrayList

    ArrayList<Integer> aList - new ArrayList<>();
    aList.add(element);
    aList.add(index, element);                                                       --->add the element to the index, if an element is already present it pushes the element and insert
    aList.set(index, element);                                                       --->replaces the element in the particular index
    aList.isEmpty();                                                                 --->Is my array list empty
    Collections.min(aList);
    Collection.max(aList);
    Collections.replaceAll(List<T> list, T old_val, T new_val);
    Collections.reverse(List);
    Collections.reverseOrder();                                                      ---> returns comparator that works in reverse order
    Collections.rotate(List l, int distance)
    Collections.shuffle(List)
    Collections.swap(List, i, j)
    Collections.fill(list, T object)
    for(int i: aList)                                                                --->In this for each loop, i is the element not index

1. HashMap
    
    HashMap<Integer, Integer> hmap = new HashMap<> ();
    hmap.put(key, value);
    hmap.get(key);
    hmap.remove(key);
    hmap.containsKey(key);
    hmap.containsValue(value);
    hmap.size();
    for(int i : hmap.keySet()) { }                                                    --->to walk through when keys are not known

2. HashSet

    HashSet<Integer> hset = new HashSet<> ();
    hset.add(value);
    hset.remove(value);
    hset.contains(value);
    hset.size();

3. PriorityQueue (If I know which element I want exactly in unsorted array, Use Heap. Quick sort is a competitor and proved to be better method, yet you can use heap)
    
    PriorityQueue<Integer> pQueue = PriorityQueue<> ();                               ---> min heap
    PriorityQueue<Integer> pQueue = PriorityQueue<> (Collections.reverseOrder());     ---> max heap
    pQueue.add(value);                                                                ---> to add value to heap
    pQueue.remove();                                                                  ---> to delete root element
    pQueue.element();                                                                 ---> to get root element
    pQueue.isEmpty();                                                                 ---> returns true if collection is empty


4. Set ----- (Set contains no duplicate elements)
    
    Set<Integer> s1;
    Set<Integer> s2;
    Set<String> yourFriends = Sets.newHashSet(List of all elements);                  ---> Declare and Initialize more than 1 element in single line
    Set<Integer> s3 = new HashSet<Integer> (s1);
    s3.addAll(s2);                                                                    ---> Union of s1 and s2
    s3.retainAll(s2);                                                                 ---> Intersection of s1 and s2

5. Map

6. StringBuffer and stringBuilder has almost same syntax. It is just that,
   StringBuilder :  stringBuilder is better than stringBuffer as it is faster. But it has no synchronization so it is not safe with multithreads. In such case, stringBuffer is used.
    StringBuilder s = new StringBuilder();                                           --->creates a empty builder
    s.append(str1);                                                                  ---> append the string representation of any data type
    s.deleteCharAt(index);
    s.delete(startIndex, endIndex);                                                  
    s.insert(index, string or char);                                                 --->  insert the char or string starting from the given index
    s.setCharAt(index, char);                                                        ---> specified index is set to the character
    s.indexOf(string)                                                                ---> return the first occurance of the substring within the string
    s.indexOf(string, fromIndex)                                                     ---> return the index of the substring starting from the fromIndex
    s.reverse();                                                                     ---> reverse string builder
    s.replace(start, end, string);                                                   ---> replace the substring between the start and end index to the given string
    s.length();                                                                      ---> return the length char inside builder
    s.capacity();                                                                    ---> returns the current capacity of the builder
    s.charAt(index);                                                                 ---> returns the character value in the sequence
    s.substring(start, end);                                                         ---> returns the new string with the substring
    String result = s.toString();                                                    ---> StringBuilder to string




7. Queue

8. Stack (extends vector class so some of vector methods can be used here)
	Stack s = new Stack();
	s.push('a'); | s.push(2); | s.push("abc");										 --->push either a char, string or int(no need to specify the type
	s.pop();																		 --->pop the top element
	s.peek();																		 --->returns the top element without popping from stack
	s.search('a') | s.search(2); | s.search("abc");									 --->search and return the index of the element(counts from top), if element not present it returns -1
	s.size(); 																		 --->returns the current size of the stack
	s.capacity();																	 --->returns the capacity of the stack, which grows in size of 10 when element is pushed

9. String
    string1.compareTo(string2);
    string1.compareToIgnoreCase(string2);
    string1.concat(string2);                                                         --->append second string to the end of first string
    string1.contains(CharSequence);

10. Float   - java.lang.Float
    Float.compare(f1, f2)                                                            --->returns less than 0 if f1 is less than f2, greater than 0 if f1 is greater than f2, 0 if equal
    

11. Array (for any primitive)
	Arrays.sort(string or int)														 --->sort array of any primitive type
	Arrays.equals(string1, string2)                 								 --->checks the equality of any two primitive in a array
	Arrays.deepEquals(string1, string2)												 --->checks the equality of two 2d matrix of any two primitive

11. Conversions
    //TO INT
    character to int                    - (int)character;                            --->This returns ascii int value of character eg: (int)3; is 51
    character to int values             - Character.getNumericValue(char);           --->This returns integer char of char eg: Character.getNumericValue('3'); is 3
    "     "       "      " with ascii   - int a = '3' - '0'; a = 3;                  --->The character 0 has ascii 49. So if we minus that it returns the actual number

    //TO STRING
    char to String                      - String.valueOf(char);
    int to String                       - String.valueOf(int);
    charArray to String                 - String string = new String(charArray);

    //TO CHAR
    int to character                    - (char)integer;
    String to char                      - string.charAt(index)
    String to char Array                - string.toCharArray();


    (Difference between char and character is that Charater is a object so many inbuilt operations can be made use of.)
12. Character
    my_char.toLowerCase();
    my_char.toUpperCase();
    my_char.isDigit();                                                              ---> Whether the char is a digit
    my_char.toString();

13. Integer

    String to Integer - 
    Integer to String - 
    Integer to float, double - 
    int to Integer and its difference?

14. Math
    Math.random() * 50 + 1;                                                          ---> returns a double value. If you want int, typecast it. Math.random gives a value between 0 and 0.999.
	Min + (int)(Math.random() * ((Max - Min) + 1))									 ---> returns value between min and max
--------------------------------------------------------------------------------------------------------------

Understanding Basics

1. difference between for loop and Iterator?
http://stackoverflow.com/questions/22267919/iterator-vs-for

2. What is boxing and Autoboxing?
Boxing is converting primitive types to corresponding object. Example is int to INTEGER object. 
List<Integer> li = new ArrayList<>();
for (int i = 1; i < 50; i += 2)
    li.add(i);																		 ---> adding int as Integer object to list
If boxing is done automatically, it is called autoboxing

UnBoxing is reverse of that.
public static int sumEven(List<Integer> li) {
    int sum = 0;
    for (Integer i: li)
        if (i % 2 == 0)                       										 ---> Integer i is calculated for its modulo with 2
            sum += i;
        return sum;
}

3.Difference between HashTable and HashMap?

	

LINUX Commands
1. cat
    - Display entire file on shell

2. touch
    - Just creates empty file

3. less
    - View file page by page

4. grep
    - search file contents
    Eg: grep -ir "foo" .
    "i" - ignores case
    "r" - recursive

5. find
    - search file names

6. Pipe |
    - Gives output of one command as input of next command
    Eg: grep -ir "for" . | grep "map" > a.txt
    Eg: grep -ir "for" . | grep "map" | more : To view page by page

7. Redirection >
    - Write output to a file
    - Creates file if not present

8. more
    - Page by page view

9. rmdir 
    - Can only delete empty directories

10. rm -rf
    r - recursive
    f - forcefully

11. ls -alht
    a - all files including hidden
    l - list view
    h - human readable size format
    t - sort by time

-----------------------------------------------------------------------------------------
VIM Shortcuts
    1. Split View
        ctrl + w v : split vertically
        ctrl + w s : split horizontally
        ctrl + h : Go right pane
        ctrl + l : Go left pane
        ctrl + j : Go bottom pane
        ctrl + k : Go top pane
    
    2. Scroll
        ctrl + d : Half page down
        ctrl + u : Half page up
        ctrl + f : Full page down
        ctrl + b : Full page up

    % : Takes you to matching brace
    ^ : First character of line
    A : Takes you to INSERT mode at END of line
    u : Undo
    ctrl + r : redo

    H : High / Head of screen
    L : Low / Bottom of screen
    M : Middle of screen

    zt : Makes your current curson postion as top of the screen
    zb : Makes your current curson postion as bottom of the screen

    . : To repeat an action that is performed.

    * : Finds current word after cursor position;
        Use 'n' and 'N' to go next and prev
    # : Finds current word before cursor position;
        Use 'n' and 'N' to go next and prev 
    / : To start searching. It has smart Case enabled
    ,/ : To clear highlighted search term
    ' : to repeat the last find char

    ,n : Open another file on the side pane in vim by showing a tree view

    Doubts in Learning:
    Can a final variable be redefined by the method that uses it? (Assume final variable is declared in the class and initialized inside method)
    Why final?  - to create a value as constant. 
        Types: 
        1. COMPILE TIME constant. create primitive data type with keyword final and initialize it before accessing it. 
                                  Value is assigned at compile time, it pre-load the value while compiling so at run time it will be easy.
                                  eg: final int a=5, int c = b+a, it writes it as c = b+5 after compilation), 
                                  Class variable declared as final should be initialized no matter if you are using it are not
                                  (In general default value will be assigned to class variable, but in case of final, the default value cannot be initialized so it need to be assigned)
        2. RUN TIME constant(value assigned in runtime) - class variable can be initialized inside constructor.
                                                        - when the object is called, it passes the value and initialize the final class variable.
                                                        - method variable can be initialized at run time. It just has to be initialized before accessing it.
        3. If class is final, I cannot inherit the class
        4. If method is final, I cannot override the method, i.e, the method cannot be rewritten by the child class when the parent class is inherited.
    why static? - all member of class can access to the same copy. It means it is shared across different object with the same value.
                - should not access static variable with object. It can be accessed by static methods only.
    
    What happens when we declare with new eg: ArrayList<Integer> arr; and ArrayList<Integer> arr = new ArrayList<Integer> ();
	If you create ArrayList arr, it just creates a reference arr that can point to a Integer arrayList in future. The new keyword creates the memory for the arr reference where you can store the values in future.
	
    http://stackoverflow.com/questions/214741/what-is-a-stackoverflowerror
	Stack memory is used to store local variables and parameters. When an recursive is called continuously, the stack stores the local variables and parameters of every recursive call which sometime may overflow stack. This is why you get the stack overflow error while the base case is not written or while running a recursive call that need to store large data.
	
    How to do swap in arraylist without using Collection function?
	Using set function, arrList.set(index, value) will replace the value that was originally present

    what is difference between function overloading and function overriding
    passing variable to a function means passing address or passing values in java?
	how to find min and max value of a floating or double point number?
	The min and max value is identified by float.compare(f1, f2). It returns -1 when f1 is smaller, 0 if f1 and f2 are equal, 1 if f2 is greater than f1

	Which is better? Declaring variable inside loop or outside?
	when is memory allocated in java? Compile time or run time
	What happens when I do? i=i+1; i+=1; i++;
	how to declare max and min value when is needed?
	How are ascii values assigned and distributed
	How to declare class that accepts any value
	public, private, protected, default
	super, final
	Can we write class inside class?
	how to write comparator
    how to convert hexadecimal to binary
    Study conversion of number system
    question on tree, see binary search tree file
    what is an object?
	what is double hashing? why is it required.
	where brute force concept can be applied
	when to use backtracking, divide and conquer
	when to use all datastructures. like circular buffer, adjacently list

	where are local variables stores while the program runs
	how are local variables and value to it is assigned and stored
	The assignment of variable will happen during compile time or run time
	what compiler does java use 
	

    DataStructures: Set, stack, queue, LinkedList, Map, tree, graph

    How to use iterator
    try catch throw complete explanation and use
    red black tree and other common tree
    bit manipulation
    what is hash tree?
    what is adjacency list
    StringBuilder
    Multithreading
    threading
    vector and arraylist diff
    trie?
    what does exactly ..void main(String args[]) do?
	radix sort?
	diff between for loop and iterator?
	

Prag teaching: 

1. Number system: Base
    Binary - 2 (0, 1) - represented as 0b
    Decimal - 10 (0-9)
    Octal - 8 (0-7) - represented as 
    Hexadecimal - 16 (0-9, a-f) - represented as 0x


